{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TMDPDF Documentation","text":"<p>This is TMDPDF project from LPC group, SJTU. Documentation of Transverse Momentum Dependent Parton Distribution Function (TMDPDF).</p>"},{"location":"#getting-start","title":"Getting Start","text":""},{"location":"#installation","title":"Installation","text":"<p>install for development</p> <pre><code>git clone `url to this repo`\ncd tmdpdf\npip install -r requirements.txt\npip install -e .\n</code></pre> <p>or install for usage</p> <pre><code>pip install git+`url to this repo`\n</code></pre>"},{"location":"#run-example-scripts","title":"Run Example Scripts","text":"<pre><code>python3 scripts/main.py\n</code></pre>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\nlibtmdpdf/\n    ...\nscripts/      # entrypoints\n</code></pre>"},{"location":"#mkdocs-commands","title":"Mkdocs Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> <li><code>mkdocs gh-deploy --force --no-history</code> - update github pages mannually.</li> </ul>"},{"location":"api/libtmdpdf.fit/","title":"libtmdpdf.fit","text":""},{"location":"api/libtmdpdf.fit/#libtmdpdf.fit","title":"<code>libtmdpdf.fit</code>","text":"<p>functions for fit</p>"},{"location":"api/libtmdpdf/","title":"libtmdpdf","text":""},{"location":"api/libtmdpdf/#libtmdpdf","title":"<code>libtmdpdf</code>","text":"<p>libtmdpdf</p>"},{"location":"api/libtmdpdf/#libtmdpdf.compat","title":"<code>libtmdpdf.compat</code>","text":"<p>old scripts, place here for compatability. This should be removed in future version.</p>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.bad_fit_check","title":"<code>libtmdpdf.compat.bad_fit_check</code>","text":"<p>check the fits quality in the dump folder</p>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.disp_relation","title":"<code>libtmdpdf.compat.disp_relation</code>","text":"<p>This code is used to make the dispersion relation plot for the 2pt with different momentum.</p>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.disp_relation.meff_fit","title":"<code>libtmdpdf.compat.disp_relation.meff_fit(t_ls, meff_ls)</code>","text":"<p>constant fit of meff</p> <p>Parameters:</p> Name Type Description Default <code>t_ls</code> required <code>meff_ls</code> required <p>Returns:</p> Type Description <p>the gvar fit result of meff</p> Source code in <code>libtmdpdf/compat/disp_relation.py</code> <pre><code>def meff_fit(t_ls, meff_ls):\n'''\n    constant fit of meff\n    Args:\n        t_ls :\n        meff_ls :\n    Returns:\n        the gvar fit result of meff\n    '''\ndef fcn(x, p):\nreturn p['meff'] + x * 0\npriors = gv.BufferDict()\npriors['meff'] = gv.gvar(1, 10)\nfit_res = lsf.nonlinear_fit(data=(t_ls, meff_ls), prior=priors, fcn=fcn, maxit=10000, svdcut=1e-100, fitter='scipy_least_squares')\nreturn fit_res.p['meff']\n</code></pre>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.funcs","title":"<code>libtmdpdf.compat.funcs</code>","text":""},{"location":"api/libtmdpdf/#libtmdpdf.compat.funcs.bootstrap","title":"<code>libtmdpdf.compat.funcs.bootstrap(conf_ls, times=500, seed_path=None)</code>","text":"<p>make sure <code>conf_ls.shape</code> = \\((N_{conf}, ...)\\)</p> <p>Returns:</p> Type Description <p>conf_ls</p> Source code in <code>libtmdpdf/compat/funcs.py</code> <pre><code>def bootstrap(conf_ls, times=500, seed_path=None):\n\"\"\"\n    make sure `conf_ls.shape` = $(N_{conf}, ...)$\n    Returns:\n        conf_ls\n    \"\"\"\n# *# If using a fixed bs_ls\nif seed_path is not None:\nbs_ls = gv.load(seed_path)\nconf_bs = np.mean(conf_ls[bs_ls], axis=1)\n# *# If generating a random bs_ls\nelse:\nidx_ls = np.random.randint(len(conf_ls), size=(times, len(conf_ls)))\nconf_bs = np.mean(conf_ls[idx_ls], axis=2)\nreturn conf_bs\n</code></pre>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.funcs.bs_ls_to_gvar_ls","title":"<code>libtmdpdf.compat.funcs.bs_ls_to_gvar_ls(bs_ls)</code>","text":"<p>This function is used to convert the bootstrap list to gvar list by combining each sample with the sdev of all samples</p> <p>The shape of <code>bs_ls</code> should be \\((N_{samp}, ...)\\)</p> Source code in <code>libtmdpdf/compat/funcs.py</code> <pre><code>def bs_ls_to_gvar_ls(bs_ls):\n\"\"\"\n    This function is used to convert the bootstrap list to gvar list by combining each sample with the sdev of all samples\n    The shape of `bs_ls` should be $(N_{samp}, ...)$\n    \"\"\"\navg = gv.dataset.avg_data(bs_ls, bstrap=True)\nsdev = gv.sdev(avg)\nreturn [gv.gvar(v, sdev) for v in bs_ls]\n</code></pre>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.funcs.gv_to_samples_corr","title":"<code>libtmdpdf.compat.funcs.gv_to_samples_corr(gv_ls, N_samp)</code>","text":"<p>transform gvar to bs samples with correlation shape = (N_samp, len(ls))</p> Source code in <code>libtmdpdf/compat/funcs.py</code> <pre><code>def gv_to_samples_corr(gv_ls, N_samp):\n\"\"\"\n    transform gvar to bs samples with correlation\n    shape = (N_samp, len(ls))\n    \"\"\"\nmean = [v.mean for v in gv_ls]\ncov_m = gv.evalcov(gv_ls)\nrng = np.random.default_rng()\nsamp_ls = rng.multivariate_normal(mean, cov_m, size=N_samp)\nreturn samp_ls\n</code></pre>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.funcs.jackknife","title":"<code>libtmdpdf.compat.funcs.jackknife(data)</code>","text":"<p>make sure <code>data.shape</code> = \\((N_{conf} * n_t)\\)</p> Source code in <code>libtmdpdf/compat/funcs.py</code> <pre><code>def jackknife(data):\n\"\"\"\n    make sure `data.shape` = $(N_{conf} * n_t)$\n    \"\"\"\nnf, nt = data.shape  # data shape: (N_conf * n_t)\ncv = np.mean(data, axis=0, keepdims=True)  # average all conf, cv shape: (1 * nt)\njac = (nf * cv - data) / (\nnf - 1\n)  # drop one data each time then average: (mean[N,:] * N_conf - data[N,:]) / (N_conf-1)\nreturn jac  # jac shape: (n_conf * n_t)\n</code></pre>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.funcs.lat_unit_convert","title":"<code>libtmdpdf.compat.funcs.lat_unit_convert(val, a, Ls, dimension)</code>","text":"<p>convert lattice unit to GeV / fm dimension: 'M', 'T'</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <p>the lattice spacing</p> required <code>Ls</code> <p>the lattice size in space direction</p> required Source code in <code>libtmdpdf/compat/funcs.py</code> <pre><code>def lat_unit_convert(val, a, Ls, dimension):\n\"\"\"\n    convert lattice unit to GeV / fm\n    dimension: 'M', 'T'\n    Args:\n        a : the lattice spacing\n        Ls : the lattice size in space direction\n    \"\"\"\nif dimension == \"P\":\n#! m * (2pi * 0.197 / Ls / a)\nreturn val * 2 * np.pi * gev_fm / Ls / a  # return in GeV\nelif dimension == \"M\":\nreturn val / a * gev_fm  # return in GeV\nelse:\nprint(\"dimension not recognized\")\nreturn None\n</code></pre>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.funcs.stability_plot","title":"<code>libtmdpdf.compat.funcs.stability_plot(x_ls, gv_y_ls, Q_ls, logGBF_ls, title, chose_idx, save=True)</code>","text":"<p>This is a general stability plot function, with three subplots: matrix elements, Q, logGBF. The input should be x list, gvar y list, Q list, logGBF list, chose_idx. chose_idx is the index in the x list, which indicates the fit that you choose to use.</p> Source code in <code>libtmdpdf/compat/funcs.py</code> <pre><code>def stability_plot(x_ls, gv_y_ls, Q_ls, logGBF_ls, title, chose_idx, save=True):\n\"\"\"\n    This is a general stability plot function, with three subplots: matrix elements, Q, logGBF.\n    The input should be x list, gvar y list, Q list, logGBF list, chose_idx.\n    chose_idx is the index in the x list, which indicates the fit that you choose to use.\n    \"\"\"\n# * Define the height ratios for each subplot\nheights = [3, 1, 1]\n# * Create the subplots and set the height ratios\nfig, axs = plt.subplots(\n3, 1, sharex=True, figsize=fig_size, gridspec_kw={\"height_ratios\": heights}\n)\n# * Plot the data on each subplot\naxs[0].errorbar(\nx_ls, [v.mean for v in gv_y_ls], [v.sdev for v in gv_y_ls], **errorb\n)\n# * Plot the chosen fit\nupper = gv_y_ls[chose_idx].mean + gv_y_ls[chose_idx].sdev\nlower = gv_y_ls[chose_idx].mean - gv_y_ls[chose_idx].sdev\naxs[0].fill_between(\nx_ls,\nnp.ones_like(x_ls) * upper,\nnp.ones_like(x_ls) * lower,\ncolor=grey,\nalpha=0.4,\n)\naxs[1].scatter(x_ls, Q_ls, marker=\"X\", facecolors=\"none\", edgecolors=\"k\", s=20)\naxs[1].plot(x_ls, 0.1 * np.ones_like(x_ls), \"r--\", linewidth=1)\naxs[2].scatter(x_ls, logGBF_ls, marker=\"o\", facecolors=\"none\", edgecolors=\"k\", s=20)\n# Add labels to the x- and y-axes\n# axs[0].set_ylabel(r'$\\Delta_{GMO}$', font)\naxs[1].set_ylabel(r\"$Q$\", font)\naxs[2].set_ylabel(r\"$logGBF$\")\nfor i in range(3):\naxs[i].tick_params(direction=\"in\", top=\"on\", right=\"on\", **ls_p)\naxs[i].grid(linestyle=\":\")\nplt.subplots_adjust(hspace=0)\naxs[0].set_title(title, font)\nif save == True:\n# TODO: save fig to `outputs` directory and add it to .gitignore\nplt.savefig(\"data/fig/\" + title + \".pdf\", transparent=True)\n# Display the plot\nplt.show()\n</code></pre>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.gs_fit_module","title":"<code>libtmdpdf.compat.gs_fit_module</code>","text":"<p>FOR CLASS Gs_Fit This is the module to do the ground state fit with bootstrap list / gvar averaged data.</p> <p>There are 2 main functions: main_bs and main_gvar, used for bootstrap list (N_bs fits) and gvar averaged data (1 fit) respectively.</p> <p>The init of this class will be the prior setting dict and fit_id, which is used for log and dump. All the fitting parameters will be set here with function para_set.</p> <p>The input of main_bs() should be a data_dic with the following keys:     data_dic['2pt_re'] = shape (N_bs, N_t)     data_dic['2pt_im'] = shape (N_bs, N_t)     data_dic['ra_re_tseq_{}'] = shape (N_bs, N_tau), here tau should start from 1 to tseq(not included)     data_dic['ra_im_tseq_{}'] = shape (N_bs, N_tau) The ouput of main_bs() will be the lists of p value, chi2, and the real / imag bare g.s. matrix elements, the lists will be in the same order as the input bs list.</p> <p>The input of main_gvar() should be a data_dic_avg with the following keys:     data_dic_avg['2pt_re'] = shape (N_t)     data_dic_avg['2pt_im'] = shape (N_t)     data_dic_avg['ra_re_tseq_{}'] = shape (N_tau), here tau should start from 1 to tseq(not included)     data_dic_avg['ra_im_tseq_{}'] = shape (N_tau) The ouput of main_gvar() will be the fit_res</p> <p>Here we do the joint fit of 2pt and ratio, FH can be added if necessary. Here we set pt2_n = ra_n = 2.</p> <p>Watch out the usage of tau_cut and tau_cut_id, here tau_cut = 0 means tau = [1, 2, 3, ..., tseq-1], tau_cut = 1 means tau = [2, 3, ..., tseq-2], etc.</p> <p>Both the fit results and the plot of the (first fit with bs_idx = 0) or (gvar averaged fit) will be saved in log folder. The log file named as '220z_P8_L6_b1_z1_tmax{}_cut{}'.</p> <p>Example usage of this class can be found in the end of the file if name == 'main' .</p>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.head","title":"<code>libtmdpdf.compat.head</code>","text":"<p>Some useful settings</p>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.plot","title":"<code>libtmdpdf.compat.plot</code>","text":""},{"location":"api/libtmdpdf/#libtmdpdf.compat.plot.fit_on_data_plot_2pt","title":"<code>libtmdpdf.compat.plot.fit_on_data_plot_2pt(x, gv_y, fit_res, key, title, log_folder, ylim=None, save=True)</code>","text":"<p>this is a general plot function to make effective mass plot with fit band on the data</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>_type_</code> <p>description</p> required <code>gv_y</code> <code>_type_</code> <p>description</p> required <code>fit_res</code> <code>_type_</code> <p>description</p> required <code>key</code> <code>_type_</code> <p>description</p> required <code>title</code> <code>_type_</code> <p>description</p> required <code>log_folder</code> <code>_type_</code> <p>description</p> required <code>ylim</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>save</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> Source code in <code>libtmdpdf/compat/plot.py</code> <pre><code>def fit_on_data_plot_2pt(\nx, gv_y, fit_res, key, title, log_folder, ylim=None, save=True\n):\n\"\"\"this is a general plot function to make effective mass plot with fit band on the data\n    Args:\n        x (_type_): _description_\n        gv_y (_type_): _description_\n        fit_res (_type_): _description_\n        key (_type_): _description_\n        title (_type_): _description_\n        log_folder (_type_): _description_\n        ylim (_type_, optional): _description_. Defaults to None.\n        save (bool, optional): _description_. Defaults to True.\n    \"\"\"\n# * data part\nmx = x[:-1]\ngv_my = pt2_to_meff(gv_y)\nmy = [v.mean for v in gv_my]\nmyerr = [v.sdev for v in gv_my]\n# * fit part\nfit_x = np.linspace(mx[0], mx[-1], 100)\ninput_x = {}\ninput_x[key] = fit_x\nfit_y = fit_res.fcn(input_x, fit_res.p)[key]\nfit_mx = []\nfit_my = []\nfit_myerr = []\nfor i in range(len(fit_x) - 1):\nval = np.log(fit_y[i]) - np.log(fit_y[i + 1])\nval = val / (fit_x[i + 1] - fit_x[i])\nfit_mx.append(fit_x[i])\nfit_my.append(val.mean)\nfit_myerr.append(val.sdev)\nfig = plt.figure(figsize=fig_size)\nax = plt.axes(plt_axes)\nax.errorbar(mx, my, myerr, label=\"data\", **errorb)\nax.fill_between(\nfit_mx,\n[fit_my[i] + fit_myerr[i] for i in range(len(fit_my))],\n[fit_my[i] - fit_myerr[i] for i in range(len(fit_my))],\nalpha=0.4,\nlabel=\"fit\",\n)\nax.tick_params(direction=\"in\", top=\"on\", right=\"on\", **ls_p)\nax.grid(linestyle=\":\")\nax.set_ylim(ylim)\nplt.title(title, font)\nplt.legend()\nif save == True:\nplt.savefig(log_folder + title + \".pdf\", transparent=True)\n</code></pre>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.plot.fit_on_data_plot_ratio","title":"<code>libtmdpdf.compat.plot.fit_on_data_plot_ratio(ra_t, ra_tau, ra_re_gv, ra_im_gv, fit_res, title, log_folder)</code>","text":"<p>This function is used to make a plot of the 3pt / 2pt ratio with fit results on the data points Plot both real and imag parts ra_t and ra_tau are just t_ls and tau_ls used for fits, ra_re_gv and ra_im_gv are the y values for fits</p> <p>Parameters:</p> Name Type Description Default <code>ra_t</code> <code>_type_</code> <p>description</p> required <code>ra_tau</code> <code>_type_</code> <p>description</p> required <code>ra_re_gv</code> <code>_type_</code> <p>description</p> required <code>ra_im_gv</code> <code>_type_</code> <p>description</p> required <code>fit_res</code> <code>_type_</code> <p>description</p> required <code>title</code> <code>_type_</code> <p>description</p> required <code>log_folder</code> <code>_type_</code> <p>description</p> required Source code in <code>libtmdpdf/compat/plot.py</code> <pre><code>def fit_on_data_plot_ratio(\nra_t, ra_tau, ra_re_gv, ra_im_gv, fit_res, title, log_folder\n):\n\"\"\"\n    This function is used to make a plot of the 3pt / 2pt ratio with fit results on the data points\n    Plot both real and imag parts\n    ra_t and ra_tau are just t_ls and tau_ls used for fits, ra_re_gv and ra_im_gv are the y values for fits\n    Args:\n        ra_t (_type_): _description_\n        ra_tau (_type_): _description_\n        ra_re_gv (_type_): _description_\n        ra_im_gv (_type_): _description_\n        fit_res (_type_): _description_\n        title (_type_): _description_\n        log_folder (_type_): _description_\n    \"\"\"\ntmin = min(ra_t)\ntmax = max(ra_t) + 1\ninput_x = {}\ninput_x[\"2pt_re\"] = np.arange(3, 10)\ninput_x[\"2pt_im\"] = np.arange(3, 10)\ninput_x[\"ra_re\"] = [ra_t, ra_tau]\ninput_x[\"ra_im\"] = [ra_t, ra_tau]\nfit_re_val = fit_res.fcn(input_x, fit_res.p)[\"ra_re\"]\nfit_im_val = fit_res.fcn(input_x, fit_res.p)[\"ra_im\"]\ntau_dic = {}\nra_re_dic = {}\nra_im_dic = {}\nfit_re_dic = {}\nfit_im_dic = {}\nfor idx in range(len(ra_t)):\nkey = \"tseq_{}\".format(ra_t[idx])\nif key not in tau_dic:\ntau_dic[key] = []\nra_re_dic[key] = []\nra_im_dic[key] = []\nfit_re_dic[key] = []\nfit_im_dic[key] = []\ntau_dic[key].append(ra_tau[idx])\nra_re_dic[key].append(ra_re_gv[idx])\nra_im_dic[key].append(ra_im_gv[idx])\nfit_re_dic[key].append(fit_re_val[idx])\nfit_im_dic[key].append(fit_im_val[idx])\n# * plot real part\nfig = plt.figure(figsize=fig_size)\nax = plt.axes(plt_axes)\nfor tseq in range(tmin, tmax):\nkey = \"tseq_{}\".format(tseq)\nax.errorbar(\nnp.array(tau_dic[key]) - tseq / 2,\n[v.mean for v in ra_re_dic[key]],\n[v.sdev for v in ra_re_dic[key]],\nlabel=\"tseq = {}\".format(tseq),\ncolor=color_ls[tseq - tmin],\n**errorb\n)\nax.fill_between(\nnp.array(tau_dic[key]) - tseq / 2,\n[v.mean + v.sdev for v in fit_re_dic[key]],\n[v.mean - v.sdev for v in fit_re_dic[key]],\ncolor=color_ls[tseq - tmin],\nalpha=0.4,\n)\nax.tick_params(direction=\"in\", top=\"on\", right=\"on\", **ls_p)\nax.grid(linestyle=\":\")\nplt.title(title + \"_real\", font)\nplt.legend(ncol=3)\nplt.xlabel(r\"$\\tau - t/2$\", font)\nplt.ylabel(r\"g.s.\", font)\nplt.savefig(log_folder + title + \"_real.pdf\", transparent=True)\n# plt.show()\n# * plot imag part\nfig = plt.figure(figsize=fig_size)\nax = plt.axes(plt_axes)\nfor tseq in range(tmin, tmax):\nkey = \"tseq_{}\".format(tseq)\nax.errorbar(\nnp.array(tau_dic[key]) - tseq / 2,\n[v.mean for v in ra_im_dic[key]],\n[v.sdev for v in ra_im_dic[key]],\nlabel=\"tseq = {}\".format(tseq),\ncolor=color_ls[tseq - tmin],\n**errorb\n)\nax.fill_between(\nnp.array(tau_dic[key]) - tseq / 2,\n[v.mean + v.sdev for v in fit_im_dic[key]],\n[v.mean - v.sdev for v in fit_im_dic[key]],\ncolor=color_ls[tseq - tmin],\nalpha=0.4,\n)\nax.tick_params(direction=\"in\", top=\"on\", right=\"on\", **ls_p)\nax.grid(linestyle=\":\")\nplt.title(title + \"_imag\", font)\nplt.legend(ncol=3)\nplt.xlabel(r\"$\\tau - t/2$\", font)\nplt.ylabel(r\"g.s.\", font)\nplt.savefig(log_folder + title + \"_imag.pdf\", transparent=True)\n</code></pre>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.plot.hist_plot","title":"<code>libtmdpdf.compat.plot.hist_plot(dic, xlabel, title, xlim=None, ylim=None, accumulate=False, save=True, figsize=(6, 6))</code>","text":"<p>define a function to make a histogram plot of a list of values.</p> <p>Parameters:</p> Name Type Description Default <code>dic</code> <code>_type_</code> <p>description</p> required <code>xlabel</code> <code>_type_</code> <p>description</p> required <code>title</code> <code>_type_</code> <p>description</p> required <code>xlim</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>ylim</code> <code>_type_</code> <p>description. Defaults to None.</p> <code>None</code> <code>accumulate</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>save</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>figsize</code> <code>tuple</code> <p>description. Defaults to (6, 6).</p> <code>(6, 6)</code> Source code in <code>libtmdpdf/compat/plot.py</code> <pre><code>def hist_plot(\ndic,\nxlabel,\ntitle,\nxlim=None,\nylim=None,\naccumulate=False,\nsave=True,\nfigsize=(6, 6),\n):\n\"\"\"\n    define a function to make a histogram plot of a list of values.\n    Args:\n        dic (_type_): _description_\n        xlabel (_type_): _description_\n        title (_type_): _description_\n        xlim (_type_, optional): _description_. Defaults to None.\n        ylim (_type_, optional): _description_. Defaults to None.\n        accumulate (bool, optional): _description_. Defaults to False.\n        save (bool, optional): _description_. Defaults to True.\n        figsize (tuple, optional): _description_. Defaults to (6, 6).\n    \"\"\"\nall = np.concatenate(list(dic.values()))\nall = all.ravel()\nfig = plt.figure(figsize=figsize)\nax = plt.axes(plt_axes)\nif accumulate == False:\n# * for chi2 plot\nfor key in dic:\nlis = dic[key]\nax.hist(lis, bins=150, density=True, rwidth=1, alpha=0.3, label=key)\nax.hist(\nall,\nbins=200,\ndensity=True,\ncolor=blue,\nrwidth=1,\nalpha=0.8,\nedgecolor=\"black\",\nlinewidth=1,\nlabel=\"Total\",\n)\ncheck = np.percentile(all, 95)\nax.axvline(check, color=\"red\", linestyle=\"dashed\", linewidth=1.5)\nax.text(\ncheck + 0.05,\n0.8,\n\"95% percentile: {}={:.2f}\".format(chi2_label, check),\ncolor=\"red\",\nfontname=\"Times New Roman\",\nfontsize=14,\n)\nelif accumulate == True:\n# * for p value plot\nfor key in dic:\nlis = dic[key]\nax.hist(\nlis,\nbins=100,\ndensity=True,\nrwidth=1,\nalpha=1,\nhisttype=\"step\",\ncumulative=True,\nlabel=key,\n)\nprint(\n\"&gt;&gt;&gt; {}: {:.2f}%\".format(\nkey, len([v for v in lis if v &lt; 0.05]) / len(lis) * 100\n)\n)\nax.hist(\nall,\nbins=200,\ncolor=blue,\ndensity=True,\nrwidth=1,\nalpha=1,\nedgecolor=\"black\",\nlinewidth=1.5,\nhisttype=\"step\",\ncumulative=True,\nlabel=\"Total\",\n)\ncheck = len([v for v in all if v &lt; 0.05]) / len(all)\nax.axvline(0.05, color=\"red\", linestyle=\"dashed\", linewidth=1.5)\nax.text(\n0.05 + 0.05,\n0.7,\n\"Proportion of Q &lt; 0.05: {:.2f}%\".format(check * 100),\ncolor=\"red\",\nfontname=\"Times New Roman\",\nfontsize=14,\n)\nax.tick_params(direction=\"in\", top=\"on\", right=\"on\", **ls_p)\nax.legend(ncol=3, prop=small_font)\nax.grid(linestyle=\":\")\nax.set_xlabel(xlabel, font)\nax.set_ylabel(\"Density\", font)\nplt.title(title, font)\nplt.xlim(xlim)\nplt.ylim(ylim)\nif save == True:\nplt.savefig(\"fig/\" + title + \".pdf\", transparent=True)\nplt.show()\n</code></pre>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.read_raw_module","title":"<code>libtmdpdf.compat.read_raw_module</code>","text":"<p>This is the module to read from the raw data file. </p> <p>The input will be the path of the raw data folder. The output will be a list with N_bs samples, they are complex. </p> <p>For 2pt, the parameters are pion mass, hadron momentum.  For 3pt, the parameters are gamma structure, pion mass, hadron momentum, L, b, z and tseq.</p> <p>gamma structure: 't', 'z' pion mass: 220, 310 hadron momentum(mom): 8, 10, 12  L(ll): 6, 8, 10</p> <p>With all the parameters, you can access to the specific data.</p> <p>Example usage can be found in the end.</p>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.renormalization_module","title":"<code>libtmdpdf.compat.renormalization_module</code>","text":"<p>This module is about the renormalization process, including Wilson loop and ZO factor.</p>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.stability_gs_fit","title":"<code>libtmdpdf.compat.stability_gs_fit</code>","text":"<p>This code is used to make stability plot for the ground state fits. Pick some (b, z) points, vary the tmin of the fit, and plot the comparison plot.</p>"},{"location":"api/libtmdpdf/#libtmdpdf.compat.stability_gs_fit.tmin_stability_plot","title":"<code>libtmdpdf.compat.stability_gs_fit.tmin_stability_plot(tmin_ls, gv_y_ls, Q_ls, logGBF_ls, title, chose_idx, save=True)</code>","text":"<p>define a stability plot function with varying tmin, 3 subplots: matrix element, p value, logGBF can be used to plot both real and imaginary parts The input should be tmin list, gvar list, Q list, logGBF list, chose_idx. chose_idx is the index in the x list, which indicates the fit that you choose to use.</p> <p>Parameters:</p> Name Type Description Default <code>tmin_ls</code> <code>_type_</code> <p>description</p> required <code>gv_y_ls</code> <code>_type_</code> <p>description</p> required <code>Q_ls</code> <code>_type_</code> <p>description</p> required <code>logGBF_ls</code> <code>_type_</code> <p>description</p> required <code>title</code> <code>_type_</code> <p>description</p> required <code>chose_idx</code> <code>_type_</code> <p>description</p> required <code>save</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> Source code in <code>libtmdpdf/compat/stability_gs_fit.py</code> <pre><code>def tmin_stability_plot(tmin_ls, gv_y_ls, Q_ls, logGBF_ls, title, chose_idx, save=True):\nR\"\"\"\n    define a stability plot function with varying tmin, 3 subplots: matrix element, p value, logGBF\n    can be used to plot both real and imaginary parts\n    The input should be tmin list, gvar list, Q list, logGBF list, chose_idx.\n    chose_idx is the index in the x list, which indicates the fit that you choose to use.\n    Args:\n        tmin_ls (_type_): _description_\n        gv_y_ls (_type_): _description_\n        Q_ls (_type_): _description_\n        logGBF_ls (_type_): _description_\n        title (_type_): _description_\n        chose_idx (_type_): _description_\n        save (bool, optional): _description_. Defaults to True.\n    \"\"\"\n# * Create the subplots and set the height ratios\nfig, axs = plt.subplots(\n3, 1, sharex=True, figsize=fig_size_Qi_An, gridspec_kw=gridspec_tmin\n)\nlabel = r\"$b = z = 1 a$\"\n# * Plot the data on each subplot\naxs[0].errorbar(\ntmin_ls,\n[v.mean for v in gv_y_ls],\n[v.sdev for v in gv_y_ls],\nlabel=label,\ncolor=\"dodgerblue\",\n**errorb\n)\n# * Plot the chosen fit\nupper = gv_y_ls[chose_idx].mean + gv_y_ls[chose_idx].sdev\nlower = gv_y_ls[chose_idx].mean - gv_y_ls[chose_idx].sdev\naxs[0].fill_between(\ntmin_ls,\nnp.ones_like(tmin_ls) * upper,\nnp.ones_like(tmin_ls) * lower,\ncolor=grey,\nalpha=0.4,\n)\naxs[1].scatter(tmin_ls, Q_ls, marker=\"X\", facecolors=\"none\", edgecolors=\"k\", s=20)\naxs[1].plot(tmin_ls, 0.1 * np.ones_like(tmin_ls), \"r--\", linewidth=1)\naxs[2].scatter(\ntmin_ls, logGBF_ls, marker=\"o\", facecolors=\"none\", edgecolors=\"k\", s=20\n)\n# Add labels to the x- and y-axes\naxs[0].set_ylabel(r\"$\\tilde{h}_{\\Gamma}^{0}$\", font_Qi_An)\naxs[1].set_ylabel(r\"$Q$\", font_Qi_An)\naxs[2].set_ylabel(r\"$\\rm logGBF$\")\n# set the ylim of the first subplot to be the mean +- 6 sigma\nmid = (upper + lower) / 2\nsigma = (upper - lower) / 2\naxs[0].set_ylim(mid - 6 * sigma, mid + 6 * sigma)\naxs[1].set_ylim(-0.3, 1.1)\n# set the ylim of the last subplot to be the avg +- 3 gap\navg = np.mean(logGBF_ls)\ngap = np.max(logGBF_ls) - np.min(logGBF_ls)\naxs[2].set_ylim(avg - 3 * gap, avg + 3 * gap)\nfor i in range(3):\naxs[i].tick_params(direction=\"out\", **ls_p)\naxs[i].grid(linestyle=\":\")\nplt.subplots_adjust(hspace=0)\n# axs[0].set_title(title, font)\naxs[2].set_xlabel(r\"$t_{\\rm min} / a$\", font_Qi_An)\naxs[2].set_xticks(np.arange(4, 7, 1))\naxs[2].set_xticklabels(np.arange(4, 7, 1, dtype=int))\naxs[0].legend(loc=\"upper left\", fontsize=fontsize_Qi_An)\nif save == True:\nplt.savefig(\"fig/\" + title + \".pdf\", transparent=True)\n# Display the plot\nplt.show()\n</code></pre>"},{"location":"api/libtmdpdf.plot/","title":"libtmdpdf.plot","text":""},{"location":"api/libtmdpdf.plot/#libtmdpdf.plot","title":"<code>libtmdpdf.plot</code>","text":"<p>functions for visualization</p>"},{"location":"api/libtmdpdf.utils/","title":"libtmdpdf.utils","text":""},{"location":"api/libtmdpdf.utils/#libtmdpdf.utils","title":"<code>libtmdpdf.utils</code>","text":"<p>misc usefull functions and classes.</p>"},{"location":"api/libtmdpdf.utils/#libtmdpdf.utils.color_logging","title":"<code>libtmdpdf.utils.color_logging</code>","text":""},{"location":"api/libtmdpdf.utils/#libtmdpdf.utils.color_logging.pprint_yaml","title":"<code>libtmdpdf.utils.color_logging.pprint_yaml = partial(pprint_code, format='yaml')</code>  <code>module-attribute</code>","text":"<p>pretty print yaml code</p>"},{"location":"api/libtmdpdf.utils/#libtmdpdf.utils.color_logging.pprint_code","title":"<code>libtmdpdf.utils.color_logging.pprint_code(code, format)</code>","text":"<p>pretty print code</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>code str</p> required <code>format</code> <code>str</code> <p>code format, for example 'yaml'</p> required Source code in <code>libtmdpdf/utils/color_logging.py</code> <pre><code>def pprint_code(code: str, format: str):\n\"\"\"pretty print code\n    Args:\n        code (str): code str\n        format (str): code format, for example 'yaml'\n    \"\"\"\ns = Syntax(code, format)\n_console.print(s)\n</code></pre>"},{"location":"api/libtmdpdf.utils/#libtmdpdf.utils.print_h5","title":"<code>libtmdpdf.utils.print_h5</code>","text":""},{"location":"api/libtmdpdf.utils/#libtmdpdf.utils.print_h5.print_h5","title":"<code>libtmdpdf.utils.print_h5.print_h5(group, level=0, logger=print)</code>","text":"<p>print h5 group to consol.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>h5py.Group</code> <p>description</p> required <code>level</code> <code>int</code> <p>description. Defaults to 0.</p> <code>0</code> <code>logger</code> <code>Callable[[Any], Any]</code> <p>print like functions</p> <code>print</code> Source code in <code>libtmdpdf/utils/print_h5.py</code> <pre><code>def print_h5(group: h5py.Group, level=0, logger: Callable[[Any], Any] = print):\n\"\"\"print h5 group to consol.\n    Args:\n        group (h5py.Group): _description_\n        level (int, optional): _description_. Defaults to 0.\n        logger (Callable[[Any], Any]): print like functions\n    \"\"\"\nif not isinstance(group, h5py.Group):\nlogger(level * \"\\t\", group)\nreturn\nelse:\nfor key in group.keys():\nlogger(level * \"\\t\" + key + \":\")\nsubgroup = group[key]\nprint_h5(subgroup, level + 1)\n</code></pre>"},{"location":"api/libtmdpdf.utils/#libtmdpdf.utils.timeit","title":"<code>libtmdpdf.utils.timeit</code>","text":""},{"location":"api/libtmdpdf.utils/#libtmdpdf.utils.timeit.TimeIt","title":"<code>libtmdpdf.utils.timeit.TimeIt</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; with TimeIt('msg'):\n    ... # do_something\n</code></pre> Source code in <code>libtmdpdf/utils/timeit.py</code> <pre><code>class TimeIt:\n\"\"\"\n    Examples:\n        &gt;&gt;&gt; with TimeIt('msg'):\n            ... # do_something\n    \"\"\"\ndef __init__(self, \ndescription: str = None, \nlogger:logging.Logger=log.info):\n\"\"\"\n        Args:\n            description (str, optional): _description_. Defaults to None.\n            logger (logging.Logger, optional): _description_. Defaults to log.info.\n        \"\"\"\nself.logger = logger\nself.description = description if description is not None else 'timeit'\ndef __enter__(self):\nself.start = time.time()\nself.logger(f'[start] {self.description}', stacklevel=2)\ndef __exit__(self, exc_type, exc_value, tb):\nself.logger(f'[end] {self.description}: {(time.time()-self.start):.2f}s', stacklevel=2)\n</code></pre>"},{"location":"api/libtmdpdf.utils/#libtmdpdf.utils.timeit.TimeIt.__init__","title":"<code>libtmdpdf.utils.timeit.TimeIt.__init__(description=None, logger=log.info)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>description. Defaults to None.</p> <code>None</code> <code>logger</code> <code>logging.Logger</code> <p>description. Defaults to log.info.</p> <code>log.info</code> Source code in <code>libtmdpdf/utils/timeit.py</code> <pre><code>def __init__(self, \ndescription: str = None, \nlogger:logging.Logger=log.info):\n\"\"\"\n    Args:\n        description (str, optional): _description_. Defaults to None.\n        logger (logging.Logger, optional): _description_. Defaults to log.info.\n    \"\"\"\nself.logger = logger\nself.description = description if description is not None else 'timeit'\n</code></pre>"}]}